import os
from datetime import datetime


def to_enum_header(db_dict, db_name):
    # start code
    print("starting parse enum to header..")
    filename = str(db_name) + "_enum"
    my_path = os.path.abspath(os.path.dirname(__file__))
    artifact_path = os.path.join(my_path, "artifacts/")
    os.makedirs(artifact_path, exist_ok=True)
    header_file = open(artifact_path + filename + ".h", "w+")

    # head
    header_file.write("/*\n")
    header_file.write(" * Enum autogenerated by CI\n")
    header_file.write(" * Build on " + str(datetime.now()) + "\n")
    header_file.write(" */\n")

    # include guard
    header_file.write("#ifndef " + filename.upper() + "_H_\n")
    header_file.write("#define " + filename.upper() + "_H_\n")
    header_file.write("\n")
    header_file.write("#ifdef __cplusplus\n")
    header_file.write('extern "C"{\n')
    header_file.write('#endif\n')
    header_file.write("\n")

    # write enum
    header_file.write("/**\n")
    header_file.write(" * @brief enum containing all CAN IDs, do not modify\n")
    header_file.write(" *\n")
    header_file.write(" */\n")
    header_file.write("enum messageName {\n")

    for s in db_dict:
        header_file.write("\t//" + s + "\n")
        for m in db_dict[s]:
            header_file.write(
                "\t" + str(m.name) + " = " + hex(m.frame_id) + ",\t///<" + str(m.name) + ": " + str(m.comment) + "\n")
        header_file.write("\n")

    header_file.write("};\n")
    # write enum end

    # include guard
    header_file.write("\n")
    header_file.write("#ifdef __cplusplus\n")
    header_file.write('}\n')
    header_file.write("#endif\n")
    header_file.write("\n")
    header_file.write("#endif /* " + filename.upper() + "_H_ */\n")

    # exit
    header_file.close()
    print("finished parsing enum to header")


def to_mapping_header(db_dict, db_name):
    # start code
    print("starting parse mappings to header..")
    filename = str(db_name) + "_mapping"
    my_path = os.path.abspath(os.path.dirname(__file__))
    artifact_path = os.path.join(my_path, "artifacts/")
    os.makedirs(artifact_path, exist_ok=True)
    header_file = open(artifact_path + filename + ".hpp", "w+")

    # head
    header_file.write("/*\n")
    header_file.write(" * Mapping autogenerated by CI\n")
    header_file.write(" * Build on " + str(datetime.now()) + "\n")
    header_file.write(" */\n")

    # include guards
    header_file.write("#ifndef " + filename.upper() + "_HPP_\n")
    header_file.write("#define " + filename.upper() + "_HPP_\n")
    header_file.write("\n")

    # includes
    header_file.write('#include <map>\n')
    header_file.write('#include <stdint.h>"\n')
    header_file.write("\n")
    header_file.write("using namespace std;\n")
    header_file.write("\n")

    # write map
    header_file.write("const map<messageName, uint8_t> messageDB {")

    for s in db_dict:
        header_file.write("\t//" + s + "\n")
        for m in db_dict[s]:
            header_file.write(
                "\t{" + str(m.name) + ", " + str(m.length) + "},\t///<" + str(m.name) + ": " + str(m.comment) + "\n")
        header_file.write("\n")

    header_file.write("};\n")
    # write map end

    # include guard
    header_file.write("\n")
    header_file.write("#endif /* " + filename.upper() + "_HPP_ */\n")

    # end
    header_file.close()
    print("finished parsing mappings to header")
