import cantools
import sys
import os
import datetime

# define global
db_name = None
db_dict = {}


def main():
    name = sys.argv[0]  # unused, for clarity

    # guard against missing argument
    if len(sys.argv) < 2:
        print("Path is missing!")
        sys.exit(1)
    else:
        dbc_path = sys.argv[1]  # put target dbc path here

    # guard against invalid path
    if not os.path.exists(dbc_path):
        print("invalid Path!")
        sys.exit(1)

    read_dbc(dbc_path)
    parse_to_enum_header()
    parse_to_mapping_header()

    print("finished")


def read_dbc(path):
    # global vars
    global db_name
    global db_dict

    # start code
    db_name = os.path.basename(path).split('.')[0]
    print("loading " + db_name + "...")

    # try loading
    try:
        db = cantools.database.load_file(path)
    except cantools.database.errors.Error as e:
        print("unable to parse db, errors in file:")
        print(e)
        sys.exit(1)

    version = db.version
    if version is None:
        version = "NA"
    elif version == "":
        version = "not set"
    print("db version: " + version + "\n")

    for m in db.messages:
        for s in m.senders:
            if s in db_dict:
                db_dict[s].append(m)
            else:
                db_dict[s] = [m]

    for s in db_dict:
        print(str(s) + ":")
        for m in db_dict[s]:
            print("\t" + str(m))
            for sg in m.signals:
                print("\t\t" + str(sg))
            print()

    print("finished loading db\n")


def parse_to_enum_header():
    # global vars
    global db_name

    # start code
    print("starting parse enum to header..")
    filename = str(db_name) + "_enum"
    header_file = open("./artifacts/" + filename + ".h", "w+")

    # head
    header_file.write("/*\n")
    header_file.write(" * Enum autogenerated by CI\n")
    header_file.write(" * Build on " + str(datetime.datetime.now()) + "\n")
    header_file.write(" */\n")

    # include guard
    header_file.write("#ifndef " + filename.upper() + "_H_\n")
    header_file.write("#define " + filename.upper() + "_H_\n")
    header_file.write("\n")
    header_file.write("#ifdef __cplusplus\n")
    header_file.write('extern "C"{\n')
    header_file.write('#endif\n')
    header_file.write("\n")

    # write enum
    header_file.write("/**\n")
    header_file.write(" * @brief enum containing all CAN IDs, do not modify\n")
    header_file.write(" *\n")
    header_file.write(" */\n")
    header_file.write("enum messageName {\n")

    for s in db_dict:
        header_file.write("\t//" + s + "\n")
        for m in db_dict[s]:
            header_file.write("\t" + str(m.name) + " = " + hex(m.frame_id) + ",\t///<" + str(m.name) + "\n")
        header_file.write("\n")

    header_file.write("};\n")
    # write enum end

    # include guard
    header_file.write("\n")
    header_file.write("#ifdef __cplusplus\n")
    header_file.write('}\n')
    header_file.write("#endif\n")
    header_file.write("\n")
    header_file.write("#endif /* " + filename.upper() + "_H_ */\n")

    # exit
    header_file.close()
    print("finished parsing enum to header")


def parse_to_mapping_header():
    # global vars
    global db_name

    # start code
    print("starting parse mappings to header..")
    filename = str(db_name) + "_mapping"
    header_file = open("./artifacts/" + filename + ".hpp", "w+")

    # head
    header_file.write("/*\n")
    header_file.write(" * Mapping autogenerated by CI\n")
    header_file.write(" * Build on " + str(datetime.datetime.now()) + "\n")
    header_file.write(" */\n")

    # include guards
    header_file.write("#ifndef " + filename.upper() + "_HPP_\n")
    header_file.write("#define " + filename.upper() + "_HPP_\n")
    header_file.write("\n")

    # includes
    header_file.write('#include <map>\n')
    header_file.write('#include <stdint.h>"\n')
    header_file.write("\n")
    header_file.write("using namespace std;\n")
    header_file.write("\n")

    # write map
    header_file.write("const map<messageName, uint8_t> messageDB {")

    for s in db_dict:
        header_file.write("\t//" + s + "\n")
        for m in db_dict[s]:
            header_file.write("\t{" + str(m.name) + ", " + str(m.length) + "},\t///<" + str(m.name) + "\n")
        header_file.write("\n")

    header_file.write("};\n")
    # write map end

    # include guard
    header_file.write("\n")
    header_file.write("#endif /* " + filename.upper() + "_HPP_ */\n")

    # end
    header_file.close()
    print("finished parsing mappings to header")


if __name__ == '__main__':
    main()
